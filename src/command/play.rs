use crate::battle::{
    builder::{BattleBuilder, RandomOption},
    model::CharaConfig,
    rpg_core::PlayMode,
};
use crate::database::{
    playdata::Entity as PlaydataEntity,
    postgres_connect,
    save::{delete as userdata_delete, save, update_player, Entity as UserDataEntity, Model},
};
use crate::setting::{
    i18n::i18n_text,
    setup::{config_parse_toml, Languages},
};
use anyhow::Context;
use once_cell::sync::Lazy;
use sea_orm::EntityTrait;
use serenity::framework::standard::macros::{command, group};
use serenity::framework::standard::{Args, CommandResult};
use serenity::model::channel::Message;
use serenity::model::channel::ReactionType;
use std::time::Duration;

pub static BATTLE_REACTIONS: Lazy<Vec<ReactionType>> = Lazy::new(|| {
    let mut vec = Vec::new();
    vec.push(ReactionType::Unicode(BATTLE_PLAY.to_string()));
    vec.push(ReactionType::Unicode(BATTLE_GUARD.to_string()));
    vec.push(ReactionType::Unicode(BATTLE_ITEM.to_string()));
    vec.push(ReactionType::Unicode(BATTLE_SAVE.to_string()));
    vec
});

pub static YES_NO_REACTIONS: Lazy<Vec<ReactionType>> = Lazy::new(|| {
    let mut vec = Vec::new();
    vec.push(ReactionType::Unicode("‚≠ï".to_string()));
    vec.push(ReactionType::Unicode("‚ùå".to_string()));
    vec
});

const BATTLE_PLAY: &str = "‚öî";
const BATTLE_ITEM: &str = "üíä";
const BATTLE_SAVE: &str = "‚úíÔ∏è";
const BATTLE_GUARD: &str = "\u{1F6E1}";

#[group]
#[commands(play, delete, setchara)]
pub struct General;

/// play
#[command]
#[description = "„Ç≤„Éº„É†„Çí„Éó„É¨„Ç§„Åô„Çã"]
pub async fn play(ctx: &serenity::client::Context, msg: &Message, args: Args) -> CommandResult {
    if !msg.author.bot {
        let postgresql_config = config_parse_toml().await.postgresql_config();
        let userdata = match &postgresql_config {
            Some(f) => {
                let db_address = f.db_address.as_ref().unwrap();
                let db_conn = postgres_connect::connect(db_address)
                    .await
                    .map_err(|e| anyhow::anyhow!(e))?;
                match UserDataEntity::find_by_id(msg.author.id.as_u64().to_string())
                    .one(&db_conn)
                    .await
                    .map_err(|e| anyhow::anyhow!(e))?
                {
                    Some(ud) => Some(ud),
                    None => {
                        let model = Model {
                            exp: 1,
                            level: 1,
                            player: "Reimu".to_string(),
                            user_id: msg.author.id.as_u64().to_string(),
                            battle_uuid: None,
                        };
                        save(&db_conn, model.clone()).await;
                        Some(model)
                    }
                }
            }
            None => None,
        };

        let playdata = match &postgresql_config {
            Some(f) => {
                let db_address = f.db_address.as_ref().unwrap();
                let db_conn = postgres_connect::connect(db_address)
                    .await
                    .map_err(|e| anyhow::anyhow!(e))?;
                match &userdata {
                    Some(r) => match r.battle_uuid {
                        Some(r) => PlaydataEntity::find_by_id(r)
                            .one(&db_conn)
                            .await
                            .map_err(|e| anyhow::anyhow!(e))?,
                        None => None,
                    },
                    None => None,
                }
            }
            None => None,
        };

        let mut battle = match playdata {
            Some(d) => {
                let builder: BattleBuilder = d.into();
                builder.build()
            }
            None => {
                let arg_playmode = match &args.current() {
                    Some(s) => match PlayMode::try_from_value(s) {
                        Ok(g) => Some(g),
                        Err(e) => {
                            error_embed_message(&ctx, &msg, format!("{} is not found", e)).await?;
                            None
                        }
                    },
                    None => None,
                };
                let mut init = BattleBuilder::new(
                    match arg_playmode {
                        Some(r) => r,
                        None => PlayMode::Simple,
                    },
                    match &userdata {
                        Some(d) => Some(d.into()),
                        None => None,
                    },
                    None,
                    None,
                );

                init.enemy_random(RandomOption::default()).await;

                init.build()
            }
        };

        msg.channel_id
            .send_message(&ctx.http, |m| {
                m.embed(|e| {
                    e.title(format!(
                        "{}{}",
                        &battle.enemy().charabase.name,
                        i18n_text(Languages::Japanese).game_message.appear_enemy
                    ))
                    .description(if &battle.elapesd_turns() != &0 {
                        format!("{}„Çø„Éº„É≥ÁõÆ„Åß„Åô", &battle.elapesd_turns())
                    } else {
                        format!("ÊúÄÂàù„Åã„Çâ„Åß„Åô")
                    })
                })
            })
            .await?;

        loop {
            if battle.turn() != battle.enemy() || battle.turn() == battle.player() {
                let operation_embed =
                    operation_enemy(&ctx, &msg, BATTLE_REACTIONS.to_vec()).await?;
                if let Some(reaction) = &operation_embed
                    .await_reaction(&ctx)
                    .timeout(Duration::from_secs(
                        config_parse_toml().await.timeout_duration().unwrap_or(10),
                    ))
                    .author_id(msg.author.id)
                    .await
                {
                    let emoji = &reaction.as_inner_ref().emoji;
                    match emoji.as_data().as_str() {
                        BATTLE_PLAY => {
                            let result = battle.result_battle().await;
                            if result.enemy().charabase.hp > 0 {
                                msg.channel_id
                                    .send_message(&ctx.http, |f| {
                                        f.embed(|e| {
                                            let enemy = result.enemy();
                                            e.title(format!("Êïµ„ÅÆ„ÅÆ„Åì„Çähp{}", enemy.charabase.hp))
                                                .description(&enemy.charabase.name)
                                        })
                                    })
                                    .await
                                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                            } else if result.enemy().charabase.hp <= 0 {
                                msg.channel_id
                                    .send_message(&ctx.http, |f| {
                                        f.embed(|e| {
                                            e.title(format!(
                                                "{}„ÇíÂÄí„Åó„Åü",
                                                result.enemy().charabase.name
                                            ))
                                        })
                                    })
                                    .await
                                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                                battle.reset_turn();
                                break;
                            } else {
                                break;
                            }
                        }
                        BATTLE_GUARD => {
                            let result = battle.result_guard().await;
                            msg.channel_id
                                .send_message(&ctx.http, |f| {
                                    f.embed(|e| {
                                        e.title(format!(
                                            "{}„ÅØÈò≤Âæ°„Åó„Åü",
                                            &result.player().charabase.name
                                        ))
                                    })
                                })
                                .await?;
                        }
                        BATTLE_SAVE => match config_parse_toml().await.postgresql_config() {
                            Some(url) => {
                                let url_string = url.db_address.unwrap();
                                let dbconn = postgres_connect::connect(url_string)
                                    .await
                                    .expect("Invelid URL");

                                save(
                                    &dbconn,
                                    Model {
                                        user_id: msg.author.id.0.to_string(),
                                        exp: match userdata.as_ref() {
                                            Some(e) => e.exp,
                                            None => 1,
                                        },
                                        level: match userdata.as_ref() {
                                            Some(l) => l.level,
                                            None => 1,
                                        },
                                        player: match userdata.as_ref() {
                                            Some(p) => p.player.clone(),
                                            None => "Reimu".to_string(),
                                        },
                                        battle_uuid: Some(battle.uuid()),
                                    },
                                )
                                .await;

                                let question = msg
                                    .channel_id
                                    .send_message(&ctx.http, |f| {
                                        f.embed(|e| {
                                            e.title("thrpg„ÇíÁ∂ö„Åë„Åæ„Åô„ÅãÔºü")
                                                .description("„Çª„Éº„Éñ„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„ÅßÁ∂ö„Åç„Çí„Éó„É¨„Ç§„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô")
                                        })
                                        .reactions(YES_NO_REACTIONS.to_vec())
                                    })
                                    .await
                                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;

                                if let Some(reaction) = &question
                                    .await_reaction(&ctx)
                                    .timeout(Duration::from_secs(
                                        config_parse_toml().await.timeout_duration().unwrap_or(10),
                                    ))
                                    .author_id(msg.author.id)
                                    .await
                                {
                                    let emoji = &reaction.as_inner_ref().emoji;
                                    match emoji.as_data().as_str() {
                                        "‚ùå" => {
                                            break;
                                        }
                                        "‚≠ï" => {
                                            msg.channel_id
                                                .send_message(&ctx.http, |f| {
                                                    f.embed(|e| e.title("thrpg„ÇíÁ∂ö„Åë„Åæ„Åô"))
                                                })
                                                .await
                                                .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                                        }
                                        _ => {
                                            error_embed_message(
                                                ctx,
                                                msg,
                                                "Ê≠£„Åó„ÅÑÂèçÂøú„ÇíÈÅ∏„Çì„Åß‰∏ã„Åï„ÅÑ",
                                            )
                                            .await?;
                                        }
                                    }
                                }
                            }
                            None => {
                                error_embed_message(ctx, msg, "„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì")
                                    .await
                                    .unwrap();
                                break;
                            }
                        },
                        _ => break,
                    }
                }
            } else if battle.elapesd_turns() == 0 && battle.turn() == battle.enemy() {
                let operation_embed =
                    operation_enemy(&ctx, &msg, BATTLE_REACTIONS.to_vec()).await?;
                battle.add_turn();
                if let Some(reaction) = &operation_embed
                    .await_reaction(&ctx)
                    .timeout(Duration::from_secs(
                        config_parse_toml().await.timeout_duration().unwrap_or(10),
                    ))
                    .author_id(msg.author.id)
                    .await
                {
                    let emoji = &reaction.as_inner_ref().emoji;
                    match emoji.as_data().as_str() {
                        BATTLE_PLAY => {
                            let result = battle.result_battle().await;
                            if result.enemy().charabase.hp > 0 {
                                msg.channel_id
                                    .send_message(&ctx.http, |f| {
                                        f.embed(|e| {
                                            let enemy = result.enemy();
                                            e.title(format!("Êïµ„ÅÆ„ÅÆ„Åì„Çähp{}", enemy.charabase.hp))
                                                .description(&enemy.charabase.name)
                                        })
                                    })
                                    .await
                                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                            } else if result.enemy().charabase.hp <= 0 {
                                msg.channel_id
                                    .send_message(&ctx.http, |f| {
                                        f.embed(|e| {
                                            e.title(format!(
                                                "{}„ÇíÂÄí„Åó„Åü",
                                                result.enemy().charabase.name
                                            ))
                                        })
                                    })
                                    .await
                                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                                battle.reset_turn();
                                break;
                            } else {
                                break;
                            }
                        }
                        BATTLE_GUARD => {
                            let result = battle.result_guard().await;
                            msg.channel_id
                                .send_message(&ctx.http, |f| {
                                    f.embed(|e| {
                                        e.title(format!(
                                            "{}„ÅØÈò≤Âæ°„Åó„Åü",
                                            &result.player().charabase.name
                                        ))
                                    })
                                })
                                .await?;
                        }
                        BATTLE_SAVE => match config_parse_toml().await.postgresql_config() {
                            Some(url) => {
                                let url_string = url.db_address.unwrap();
                                let dbconn = postgres_connect::connect(url_string)
                                    .await
                                    .expect("Invelid URL");

                                save(
                                    &dbconn,
                                    crate::database::save::Model {
                                        user_id: msg.author.id.0.to_string(),
                                        exp: match userdata.as_ref() {
                                            Some(e) => e.exp,
                                            None => 1,
                                        },
                                        level: match userdata.as_ref() {
                                            Some(l) => l.level,
                                            None => 1,
                                        },
                                        player: match userdata.as_ref() {
                                            Some(p) => p.player.clone(),
                                            None => "Reimu".to_string(),
                                        },
                                        battle_uuid: Some(battle.uuid()),
                                    },
                                )
                                .await;

                                let question = msg
                                    .channel_id
                                    .send_message(&ctx.http, |f| {
                                        f.embed(|e| {
                                            e.title("thrpg„ÇíÁ∂ö„Åë„Åæ„Åô„ÅãÔºü")
                                                .description("„Çª„Éº„Éñ„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„ÅßÁ∂ö„Åç„Çí„Éó„É¨„Ç§„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô")
                                        })
                                        .reactions(YES_NO_REACTIONS.to_vec())
                                    })
                                    .await
                                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;

                                if let Some(reaction) = &question
                                    .await_reaction(&ctx)
                                    .timeout(Duration::from_secs(
                                        config_parse_toml().await.timeout_duration().unwrap_or(10),
                                    ))
                                    .author_id(msg.author.id)
                                    .await
                                {
                                    let emoji = &reaction.as_inner_ref().emoji;
                                    match emoji.as_data().as_str() {
                                        "‚ùå" => {
                                            break;
                                        }
                                        "‚≠ï" => {
                                            msg.channel_id
                                                .send_message(&ctx.http, |f| {
                                                    f.embed(|e| e.title("thrpg„ÇíÁ∂ö„Åë„Åæ„Åô"))
                                                })
                                                .await
                                                .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                                        }
                                        _ => {
                                            error_embed_message(
                                                ctx,
                                                msg,
                                                "Ê≠£„Åó„ÅÑÂèçÂøú„ÇíÈÅ∏„Çì„Åß‰∏ã„Åï„ÅÑ",
                                            )
                                            .await?;
                                        }
                                    }
                                }
                            }
                            None => {
                                error_embed_message(ctx, msg, "„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì")
                                    .await
                                    .unwrap();
                                break;
                            }
                        },
                        _ => break,
                    }
                }
            } else {
                let result = battle.result_battle().await;
                if result.player().charabase.hp > 0 {
                    msg.channel_id
                        .send_message(&ctx.http, |f| {
                            f.embed(|e| {
                                let player = result.player();
                                e.title(format!("Âë≥Êñπ„ÅÆ„ÅÆ„Åì„Çähp{}", player.charabase.hp))
                                    .description(&player.charabase.name)
                            })
                        })
                        .await
                        .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                } else if result.player().charabase.hp <= 0 {
                    msg.channel_id
                        .send_message(&ctx.http, |f| {
                            f.embed(|e| {
                                e.title(format!(
                                    "{}„Å´ÂÄí„Åï„Çå„Å¶„Åó„Åæ„Å£„Åü",
                                    result.enemy().charabase.name
                                ))
                            })
                        })
                        .await
                        .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
                    battle.reset_turn();
                    break;
                } else {
                    break;
                }
            }
        }
    }
    Ok(())
}

#[command]
#[description = "„Çª„Éº„Éñ„Éá„Éº„Çø„ÇíÂâäÈô§„Åô„Çã"]
pub async fn delete(ctx: &serenity::client::Context, msg: &Message) -> CommandResult {
    let question = msg
        .channel_id
        .send_message(&ctx.http, |f| {
            f.embed(|e| {
                e.title("Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü")
                    .description("ÂâäÈô§„Åó„Åü„Éá„Éº„Çø„ÅØ‰∫åÂ∫¶„Å®Êàª„Å£„Å¶„Åç„Åæ„Åõ„Çì")
            })
            .reactions(YES_NO_REACTIONS.to_vec())
        })
        .await
        .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;

    if let Some(reaction) = &question
        .await_reaction(&ctx)
        .timeout(Duration::from_secs(
            config_parse_toml().await.timeout_duration().unwrap_or(10),
        ))
        .author_id(msg.author.id)
        .await
    {
        let emoji = &reaction.as_inner_ref().emoji;
        match emoji.as_data().as_str() {
            "‚≠ï" => match config_parse_toml().await.postgresql_config() {
                Some(url) => {
                    let url_string = url.db_address.unwrap();
                    let dbconn = postgres_connect::connect(url_string)
                        .await
                        .expect("Invelid URL");
                    userdata_delete(&dbconn, *msg.author.id.as_u64()).await;
                }
                None => {
                    error_embed_message(ctx, msg, "„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì").await?;
                }
            },
            "‚ùå" => {
                msg.channel_id
                    .send_message(&ctx.http, |f| f.embed(|e| e.title("ÂâäÈô§„ÇíÂèñ„ÇäÊ∂à„Åó„Åæ„Åô")))
                    .await
                    .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;
            }
            _ => {
                error_embed_message(ctx, msg, "Ê≠£„Åó„ÅÑÂèçÂøú„ÇíÈÅ∏„Çì„Åß‰∏ã„Åï„ÅÑ").await?;
            }
        }
    }

    Ok(())
}

#[command]
#[description = "„Ç≠„É£„É©„ÇØ„Çø„Éº„ÇíÈÅ∏Êäû„Åó„Åæ„Åô"]
pub async fn setchara(
    ctx: &serenity::client::Context,
    msg: &Message,
    mut arg: Args,
) -> CommandResult {
    let arg_str = arg.trimmed().current();
    if let Some(arg) = arg_str {
        let chara_data = CharaConfig::chara_new(&arg.to_string())
            .await
            .context("Invalid arg")?;
        msg.channel_id
            .send_message(&ctx.http, |f| {
                f.embed(|e| {
                    e.title(format!(
                        "„Ç≠„É£„É©„ÇØ„Çø„Éº„Çí{}„Å´Â§âÊõ¥„Åó„Åæ„Åó„Åü",
                        &chara_data.charabase.name
                    ))
                    .description(" ")
                })
            })
            .await
            .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")?;

        match config_parse_toml().await.postgresql_config() {
            Some(url) => {
                let url_string = url.db_address.unwrap();
                let dbconn = postgres_connect::connect(url_string)
                    .await
                    .expect("Invelid URL");
                update_player(&dbconn, msg.author.id.0, chara_data.charabase.name).await;
            }
            None => {
                error_embed_message(ctx, msg, "„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì").await?;
            }
        }
    } else {
        error_embed_message(&ctx, &msg, "‰Ωï„ÅÆ„Ç≠„É£„É©„ÇØ„Çø„Éº„ÇÇÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì").await?;
    }

    Ok(())
}
/// Êìç‰Ωú„ÅÆÂüã„ÇÅËæº„Åø
async fn operation_enemy(
    ctx: &serenity::client::Context,
    msg: &Message,
    reactions: Vec<ReactionType>,
) -> Result<Message, anyhow::Error> {
    msg.channel_id
        .send_message(&ctx.http, |f| {
            f.embed(|e| e.title("„É™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊäº„Åó„Å¶Êìç‰Ωú„Åó„Å¶„Å≠").description(" "))
                .reactions(reactions.into_iter())
        })
        .await
        .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
}

async fn error_embed_message<M: Into<String>>(
    ctx: &serenity::client::Context,
    msg: &Message,
    context: M,
) -> Result<Message, anyhow::Error> {
    msg.channel_id
        .send_message(&ctx.http, |f| {
            f.embed(|e| e.title("„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü").description(context.into()))
        })
        .await
        .context("Âüã„ÇÅËæº„Åø„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
}
